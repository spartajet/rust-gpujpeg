/* automatically generated by rust-bindgen 0.71.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_CXX26: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const GPUJPEG_MAX_COMPONENT_COUNT: u32 = 4;
pub const GPUJPEG_INIT_DEV_VERBOSE: u32 = 1;
pub const GPUJPEG_OPENGL_INTEROPERABILITY: u32 = 2;
pub const GPUJPEG_VERBOSE: u32 = 1;
pub const GPUJPEG_MAX_SEGMENT_INFO_HEADER_COUNT: u32 = 100;
pub const GPUJPEG_NOERR: u32 = 0;
pub const GPUJPEG_ERROR: i32 = -1;
pub const GPUJPEG_ERR_RESTART_CHANGE: i32 = -2;
pub const GPUJPEG_VAL_TRUE: &[u8; 2] = b"1\0";
pub const GPUJPEG_VAL_FALSE: &[u8; 2] = b"0\0";
pub const GPUJPEG_MAX_DEVICE_COUNT: u32 = 10;
pub const GPUJPEG_SUBSAMPLING_UNKNOWN: u32 = 0;
pub const GPUJPEG_ENCODER_OPT_OUT_PINNED: &[u8; 15] = b"enc_out_pinned\0";
pub const GPUJPEG_ENC_OPT_OUT: &[u8; 12] = b"enc_opt_out\0";
pub const GPUJPEG_ENC_OUT_VAL_PAGEABLE: &[u8; 21] = b"enc_out_val_pageable\0";
pub const GPUJPEG_ENC_OUT_VAL_PINNED: &[u8; 19] = b"enc_out_val_pinned\0";
pub const GPUJPEG_DEC_OPT_TGA_RLE_BOOL: &[u8; 16] = b"dec_opt_tga_rle\0";
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
unsafe extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
unsafe extern "C" {
    pub fn __security_init_cookie();
}
unsafe extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
unsafe extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
unsafe extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub const gpujpeg_color_space_GPUJPEG_NONE: gpujpeg_color_space = 0;
pub const gpujpeg_color_space_GPUJPEG_RGB: gpujpeg_color_space = 1;

///limited-range YCbCr BT.601
pub const gpujpeg_color_space_GPUJPEG_YCBCR_BT601: gpujpeg_color_space = 2;

/// GPUJPEG_YCBCR_BT601
pub const gpujpeg_color_space_GPUJPEG_YCBCR_BT601_256LVLS: gpujpeg_color_space = 3;
/// limited-range YCbCr JPEG
pub const gpujpeg_color_space_GPUJPEG_YCBCR_JPEG: gpujpeg_color_space = 3;
/// limited-range YCbCr BT.709
/// GPUJPEG_YCBCR_BT709
pub const gpujpeg_color_space_GPUJPEG_YCBCR_BT709: gpujpeg_color_space = 4;
/// @ref GPUJPEG_YCBCR_BT709
/// GPUJPEG_YCBCR_BT709_256LVLS
pub const gpujpeg_color_space_GPUJPEG_YCBCR: gpujpeg_color_space = 4;
/// @deprecated will be removed soon (is this ever needed?), define ENABLE_YUV to enable pre/post processors

pub const gpujpeg_color_space_GPUJPEG_YUV: gpujpeg_color_space = 5;
/// Color spaces for JPEG codec
pub type gpujpeg_color_space = ::std::os::raw::c_int;
pub const gpujpeg_pixel_format_GPUJPEG_PIXFMT_NONE: gpujpeg_pixel_format = -1;
/// 8bit unsigned samples, 1 component
pub const gpujpeg_pixel_format_GPUJPEG_U8: gpujpeg_pixel_format = 0;
/// 8bit unsigned samples, 3 components, 4:4:4 sampling,
/// sample order: comp#0 comp#1 comp#2, interleaved
pub const gpujpeg_pixel_format_GPUJPEG_444_U8_P012: gpujpeg_pixel_format = 1;
/// 8bit unsigned samples, 3 components, 4:4:4, planar
pub const gpujpeg_pixel_format_GPUJPEG_444_U8_P0P1P2: gpujpeg_pixel_format = 2;
/// 8bit unsigned samples, 3 components, 4:2:2,
/// order of samples: comp#1 comp#0 comp#2 comp#0, interleaved
pub const gpujpeg_pixel_format_GPUJPEG_422_U8_P1020: gpujpeg_pixel_format = 3;
/// 8bit unsigned samples, planar, 3 components, 4:2:2, planar
pub const gpujpeg_pixel_format_GPUJPEG_422_U8_P0P1P2: gpujpeg_pixel_format = 4;
/// 8bit unsigned samples, planar, 3 components, 4:2:0, planar
pub const gpujpeg_pixel_format_GPUJPEG_420_U8_P0P1P2: gpujpeg_pixel_format = 5;
/// 8bit unsigned samples, 3 or 4 components, each pixel padded to 32bits
/// with optional alpha or unused, 4:4:4(:4) sampling, interleaved
pub const gpujpeg_pixel_format_GPUJPEG_4444_U8_P0123: gpujpeg_pixel_format = 6;
/// Pixel format for input/output image data.
pub type gpujpeg_pixel_format = ::std::os::raw::c_int;
/// Sampling factor for color component in JPEG format
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_component_sampling_factor {
    pub horizontal: u8,
    pub vertical: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_component_sampling_factor"]
        [::std::mem::size_of::<gpujpeg_component_sampling_factor>() - 2usize];
    ["Alignment of gpujpeg_component_sampling_factor"]
        [::std::mem::align_of::<gpujpeg_component_sampling_factor>() - 1usize];
    ["Offset of field: gpujpeg_component_sampling_factor::horizontal"]
        [::std::mem::offset_of!(gpujpeg_component_sampling_factor, horizontal) - 0usize];
    ["Offset of field: gpujpeg_component_sampling_factor::vertical"]
        [::std::mem::offset_of!(gpujpeg_component_sampling_factor, vertical) - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type cudaStream_t = *mut CUstream_st;
unsafe extern "C" {
    /// # return
    /// runtime version of the GPUJPEG library
    pub fn gpujpeg_version() -> ::std::os::raw::c_int;
}

unsafe extern "C" {
    /// # return
    /// text representation of GPUJPEG version number
    pub fn gpujpeg_version_to_string(
        version: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    /// # return
    /// current time in seconds
    pub fn gpujpeg_get_time() -> f64;
}
/// Device info for one device
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_device_info {
    /// Device id
    pub id: ::std::os::raw::c_int,
    /// Device name
    pub name: [::std::os::raw::c_char; 256usize],
    /// Compute capability major version
    pub cc_major: ::std::os::raw::c_int,
    /// Compute capability minor version
    pub cc_minor: ::std::os::raw::c_int,
    /// Amount of global memory
    pub global_memory: usize,
    /// Amount of constant memory
    pub constant_memory: usize,
    /// Amount of shared memory
    pub shared_memory: usize,
    /// Number of registers per block
    pub register_count: ::std::os::raw::c_int,
    /// Number of multiprocessors
    pub multiprocessor_count: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_device_info"][::std::mem::size_of::<gpujpeg_device_info>() - 304usize];
    ["Alignment of gpujpeg_device_info"][::std::mem::align_of::<gpujpeg_device_info>() - 8usize];
    ["Offset of field: gpujpeg_device_info::id"]
        [::std::mem::offset_of!(gpujpeg_device_info, id) - 0usize];
    ["Offset of field: gpujpeg_device_info::name"]
        [::std::mem::offset_of!(gpujpeg_device_info, name) - 4usize];
    ["Offset of field: gpujpeg_device_info::cc_major"]
        [::std::mem::offset_of!(gpujpeg_device_info, cc_major) - 260usize];
    ["Offset of field: gpujpeg_device_info::cc_minor"]
        [::std::mem::offset_of!(gpujpeg_device_info, cc_minor) - 264usize];
    ["Offset of field: gpujpeg_device_info::global_memory"]
        [::std::mem::offset_of!(gpujpeg_device_info, global_memory) - 272usize];
    ["Offset of field: gpujpeg_device_info::constant_memory"]
        [::std::mem::offset_of!(gpujpeg_device_info, constant_memory) - 280usize];
    ["Offset of field: gpujpeg_device_info::shared_memory"]
        [::std::mem::offset_of!(gpujpeg_device_info, shared_memory) - 288usize];
    ["Offset of field: gpujpeg_device_info::register_count"]
        [::std::mem::offset_of!(gpujpeg_device_info, register_count) - 296usize];
    ["Offset of field: gpujpeg_device_info::multiprocessor_count"]
        [::std::mem::offset_of!(gpujpeg_device_info, multiprocessor_count) - 300usize];
};
/// Device info for one device
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_devices_info {
    /// Number of devices
    pub device_count: ::std::os::raw::c_int,
    /// Device info for each
    pub device: [gpujpeg_device_info; 10usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_devices_info"][::std::mem::size_of::<gpujpeg_devices_info>() - 3048usize];
    ["Alignment of gpujpeg_devices_info"][::std::mem::align_of::<gpujpeg_devices_info>() - 8usize];
    ["Offset of field: gpujpeg_devices_info::device_count"]
        [::std::mem::offset_of!(gpujpeg_devices_info, device_count) - 0usize];
    ["Offset of field: gpujpeg_devices_info::device"]
        [::std::mem::offset_of!(gpujpeg_devices_info, device) - 8usize];
};
unsafe extern "C" {
    /// Get information about available devices
    ///
    /// # return
    /// devices info
    pub fn gpujpeg_get_devices_info() -> gpujpeg_devices_info;
}
unsafe extern "C" {
    /// Print information about available devices
    ///
    /// # return
    /// 0 if success
    /// # return
    /// -1 for error (eg. no devices were found)
    pub fn gpujpeg_print_devices_info() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Init CUDA device
    ///
    /// @param device_id CUDA device id (starting at 0)
    /// @param flags @ref Flags, e.g. if device info should be printed out (@ref GPUJPEG_INIT_DEV_VERBOSE) or
    ///              enable OpenGL interoperability (@ref GPUJPEG_OPENGL_INTEROPERABILITY)
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_init_device(
        device_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
/// auto-select the best restart interval
pub const restart_int_RESTART_AUTO: restart_int = -1;
/// disabled; CPU Huffman encoder will be used
pub const restart_int_RESTART_NONE: restart_int = 0;
pub type restart_int = ::std::os::raw::c_int;
/// suppress informative messages (but not warnings and errors)
pub const verbosity_GPUJPEG_LL_QUIET: verbosity = -1;
/// normal verbosity
pub const verbosity_GPUJPEG_LL_INFO: verbosity = 0;
/// print summary (image size, duration)
pub const verbosity_GPUJPEG_LL_STATUS: verbosity = 1;
/// print additional information
pub const verbosity_GPUJPEG_LL_VERBOSE: verbosity = 2;
/// print more information, including internal ones
pub const verbosity_GPUJPEG_LL_DEBUG: verbosity = 3;
/// print maximum of information, including JPEG file internal structure
pub const verbosity_GPUJPEG_LL_DEBUG2: verbosity = 4;
pub type verbosity = ::std::os::raw::c_int;
/// JPEG parameters. This structure should not be initialized only be hand,
/// but at first gpujpeg_set_default_parameters should be call and then
/// some parameters could be changed.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_parameters {
    /// Verbosity level - show more information, collects duration of each phase, etc.
    /// @sa @ref verbosity for values
    pub verbose: ::std::os::raw::c_int,
    pub perf_stats: ::std::os::raw::c_int,
    /// Encoder quality level (0-100)
    pub quality: ::std::os::raw::c_int,
    /// Restart interval (0 means that restart interval is disabled and CPU huffman coder is used)
    /// @sa @rf restart_int for special values
    pub restart_interval: ::std::os::raw::c_int,
    /// Flag which determines if interleaved format of JPEG stream should be used, \"1\" = only
    /// one scan which includes all color components (e.g. Y Cb Cr Y Cb Cr ...),
    /// or \"0\" = one scan for each color component (e.g. Y Y Y ..., Cb Cb Cb ..., Cr Cr Cr ...)
    pub interleaved: ::std::os::raw::c_int,
    /// Use segment info in stream for fast decoding. The segment info is placed into special
    /// application headers and contains indexes to beginnings of segments in the stream, so
    /// the decoder don't have to parse the stream byte-by-byte but he can only read the
    /// segment info and start decoding. The segment info is presented for each scan, and thus
    /// the best result is achieved when it is used in combination with \"interleaved = 1\" settings.
    pub segment_info: ::std::os::raw::c_int,
    /// JPEG image component count; count of valid sampling_factor elements
    /// use gpujpeg_parameters_chroma_subsampling() to set comp_count and sampling_factor
    pub comp_count: ::std::os::raw::c_int,
    /// Sampling factors for each color component inside JPEG stream.
    pub sampling_factor: [gpujpeg_component_sampling_factor; 4usize],
    /// Color space that is used inside JPEG stream = that is carried in JPEG format = to
    /// which are input data converted. Default value is @ref GPUJPEG_YCBCR_JPEG, changing it
    /// will change the JPEG format from @ref GPUJPEG_HEADER_JFIF \"JFIF\" (see also @ref
    /// gpujpeg_encoder_set_jpeg_header).
    /// - encoding: Set by user
    /// - decoding: Set by gpujpeg
    pub color_space_internal: gpujpeg_color_space,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_parameters"][::std::mem::size_of::<gpujpeg_parameters>() - 40usize];
    ["Alignment of gpujpeg_parameters"][::std::mem::align_of::<gpujpeg_parameters>() - 4usize];
    ["Offset of field: gpujpeg_parameters::verbose"]
        [::std::mem::offset_of!(gpujpeg_parameters, verbose) - 0usize];
    ["Offset of field: gpujpeg_parameters::perf_stats"]
        [::std::mem::offset_of!(gpujpeg_parameters, perf_stats) - 4usize];
    ["Offset of field: gpujpeg_parameters::quality"]
        [::std::mem::offset_of!(gpujpeg_parameters, quality) - 8usize];
    ["Offset of field: gpujpeg_parameters::restart_interval"]
        [::std::mem::offset_of!(gpujpeg_parameters, restart_interval) - 12usize];
    ["Offset of field: gpujpeg_parameters::interleaved"]
        [::std::mem::offset_of!(gpujpeg_parameters, interleaved) - 16usize];
    ["Offset of field: gpujpeg_parameters::segment_info"]
        [::std::mem::offset_of!(gpujpeg_parameters, segment_info) - 20usize];
    ["Offset of field: gpujpeg_parameters::comp_count"]
        [::std::mem::offset_of!(gpujpeg_parameters, comp_count) - 24usize];
    ["Offset of field: gpujpeg_parameters::sampling_factor"]
        [::std::mem::offset_of!(gpujpeg_parameters, sampling_factor) - 28usize];
    ["Offset of field: gpujpeg_parameters::color_space_internal"]
        [::std::mem::offset_of!(gpujpeg_parameters, color_space_internal) - 36usize];
};
unsafe extern "C" {
    /// Set default parameters for JPEG coder
    ///
    /// @param param Parameters for JPEG coder
    /// # return
    /// void
    /// @sa gpujpeg_default_parameters
    pub fn gpujpeg_set_default_parameters(param: *mut gpujpeg_parameters);
}
unsafe extern "C" {
    /// alternative to @ref gpujpeg_set_default_parameters allowing simultaneous
    /// declaration and intialization for convenience.
    pub fn gpujpeg_default_parameters() -> gpujpeg_parameters;
}
/// Sampling factor for all components
pub type gpujpeg_sampling_factor_t = u32;
unsafe extern "C" {
    /// Set parameters for using specified chroma subsampling
    /// @param param       parameters for coder
    /// @param subsampling one of GPUJPEG_SUBSAMPLING_{444,422,420}
    pub fn gpujpeg_parameters_chroma_subsampling(
        param: *mut gpujpeg_parameters,
        subsampling: gpujpeg_sampling_factor_t,
    );
}
unsafe extern "C" {
    /// Returns convenient name for subsampling (4:2:0 etc.). If it cannot be constructed
    /// returns the format W1xH1:W2xH2:W3xH3.
    pub fn gpujpeg_subsampling_get_name(
        comp_count: ::std::os::raw::c_int,
        sampling_factor: *const gpujpeg_component_sampling_factor,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    /// returns gpujpeg_sampling_factor_t from textual representation of subsampling
    ///
    /// @retval subsampling, GPUJPEG_SUBSAMPLING_UNKNOWN if not recognized
    pub fn gpujpeg_subsampling_from_name(
        subsampling: *const ::std::os::raw::c_char,
    ) -> gpujpeg_sampling_factor_t;
}
/// Image parameters. This structure should not be initialized only be hand,
/// but at first gpujpeg_image_set_default_parameters should be call and then
/// some parameters could be changed.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_image_parameters {
    /// Image data width
    pub width: ::std::os::raw::c_int,
    /// Image data height
    pub height: ::std::os::raw::c_int,
    /// Image data color space
    pub color_space: gpujpeg_color_space,
    /// Image data sampling factor
    pub pixel_format: gpujpeg_pixel_format,
    /// Number of bytes padded to each row
    pub width_padding: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_image_parameters"]
        [::std::mem::size_of::<gpujpeg_image_parameters>() - 20usize];
    ["Alignment of gpujpeg_image_parameters"]
        [::std::mem::align_of::<gpujpeg_image_parameters>() - 4usize];
    ["Offset of field: gpujpeg_image_parameters::width"]
        [::std::mem::offset_of!(gpujpeg_image_parameters, width) - 0usize];
    ["Offset of field: gpujpeg_image_parameters::height"]
        [::std::mem::offset_of!(gpujpeg_image_parameters, height) - 4usize];
    ["Offset of field: gpujpeg_image_parameters::color_space"]
        [::std::mem::offset_of!(gpujpeg_image_parameters, color_space) - 8usize];
    ["Offset of field: gpujpeg_image_parameters::pixel_format"]
        [::std::mem::offset_of!(gpujpeg_image_parameters, pixel_format) - 12usize];
    ["Offset of field: gpujpeg_image_parameters::width_padding"]
        [::std::mem::offset_of!(gpujpeg_image_parameters, width_padding) - 16usize];
};
unsafe extern "C" {
    /// Set default parameters for JPEG image
    ///
    /// @param param  Parameters for image
    /// # return
    /// void
    pub fn gpujpeg_image_set_default_parameters(param: *mut gpujpeg_image_parameters);
}
unsafe extern "C" {
    /// alternative to @ref gpujpeg_set_default_image_parameters allowing
    ///simultaneous * declaration and intialization for convenience.
    pub fn gpujpeg_default_image_parameters() -> gpujpeg_image_parameters;
}
/// Unknown image file format
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_UNKNOWN: gpujpeg_image_file_format = 0;
/// JPEG file format
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_JPEG: gpujpeg_image_file_format = 1;
/// Raw file format
/// # note all following formats must be raw
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_RAW: gpujpeg_image_file_format = 2;
/// Gray file format
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_GRAY: gpujpeg_image_file_format = 3;
/// RGB file format, simple data format without header [R G B] [R G B] ...
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_RGB: gpujpeg_image_file_format = 4;
/// RGBA file format, simple data format without header [R G B A] [R G B A] ...
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_RGBA: gpujpeg_image_file_format = 5;
/// RGBA file format, simple data format without header [R G B A] [R G B A] ...
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_BMP: gpujpeg_image_file_format = 6;
/// RGBA file format, simple data format without header [R G B A] [R G B A] ...
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_GIF: gpujpeg_image_file_format = 7;
/// RGBA file format, simple data format without header [R G B A] [R G B A] ...
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_PNG: gpujpeg_image_file_format = 8;
/// RGBA file format, simple data format without header [R G B A] [R G B A] ...
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_TGA: gpujpeg_image_file_format = 9;
/// PNM file format
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_PGM: gpujpeg_image_file_format = 10;
/// PNM file format
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_PPM: gpujpeg_image_file_format = 11;
/// PNM file format
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_PNM: gpujpeg_image_file_format = 12;
/// PAM file format
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_PAM: gpujpeg_image_file_format = 13;
/// PAM file format
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_Y4M: gpujpeg_image_file_format = 14;
/// YUV file format, simple data format without header [Y U V] [Y U V] ...
/// # note all following formats must be YUV
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_YUV: gpujpeg_image_file_format = 15;
/// YUV file format with alpha channel [Y U V A] [Y U V A] ...
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_YUVA: gpujpeg_image_file_format = 16;
/// UYVY - packed YUV 4:2:2 with pattern U Y0 V Y1
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_UYVY: gpujpeg_image_file_format = 17;
/// i420 file format
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_I420: gpujpeg_image_file_format = 18;
/// testing (empty) image, that is SW generated
pub const gpujpeg_image_file_format_GPUJPEG_IMAGE_FILE_TST: gpujpeg_image_file_format = 19;
/// Image file formats
///
/// # note if modifying the enum, check the macros below
pub type gpujpeg_image_file_format = ::std::os::raw::c_int;
/// Encoder/decoder fine-grained statistics with duration of individual steps
/// of JPEG compression/decompression. All values are in milliseconds.
///
/// # note
/// The values are only informative and for debugging only and thus this is
/// not considered as a part of a public API.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_duration_stats {
    pub duration_memory_to: f64,
    pub duration_memory_from: f64,
    pub duration_memory_map: f64,
    pub duration_memory_unmap: f64,
    pub duration_preprocessor: f64,
    pub duration_dct_quantization: f64,
    pub duration_huffman_coder: f64,
    pub duration_stream: f64,
    pub duration_in_gpu: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_duration_stats"][::std::mem::size_of::<gpujpeg_duration_stats>() - 72usize];
    ["Alignment of gpujpeg_duration_stats"]
        [::std::mem::align_of::<gpujpeg_duration_stats>() - 8usize];
    ["Offset of field: gpujpeg_duration_stats::duration_memory_to"]
        [::std::mem::offset_of!(gpujpeg_duration_stats, duration_memory_to) - 0usize];
    ["Offset of field: gpujpeg_duration_stats::duration_memory_from"]
        [::std::mem::offset_of!(gpujpeg_duration_stats, duration_memory_from) - 8usize];
    ["Offset of field: gpujpeg_duration_stats::duration_memory_map"]
        [::std::mem::offset_of!(gpujpeg_duration_stats, duration_memory_map) - 16usize];
    ["Offset of field: gpujpeg_duration_stats::duration_memory_unmap"]
        [::std::mem::offset_of!(gpujpeg_duration_stats, duration_memory_unmap) - 24usize];
    ["Offset of field: gpujpeg_duration_stats::duration_preprocessor"]
        [::std::mem::offset_of!(gpujpeg_duration_stats, duration_preprocessor) - 32usize];
    ["Offset of field: gpujpeg_duration_stats::duration_dct_quantization"]
        [::std::mem::offset_of!(gpujpeg_duration_stats, duration_dct_quantization) - 40usize];
    ["Offset of field: gpujpeg_duration_stats::duration_huffman_coder"]
        [::std::mem::offset_of!(gpujpeg_duration_stats, duration_huffman_coder) - 48usize];
    ["Offset of field: gpujpeg_duration_stats::duration_stream"]
        [::std::mem::offset_of!(gpujpeg_duration_stats, duration_stream) - 56usize];
    ["Offset of field: gpujpeg_duration_stats::duration_in_gpu"]
        [::std::mem::offset_of!(gpujpeg_duration_stats, duration_in_gpu) - 64usize];
};
unsafe extern "C" {
    /// Get image file format from filename
    ///
    /// @param filename  Filename of image file
    /// # return
    /// image_file_format or GPUJPEG_IMAGE_FILE_UNKNOWN if type cannot be determined
    pub fn gpujpeg_image_get_file_format(
        filename: *const ::std::os::raw::c_char,
    ) -> gpujpeg_image_file_format;
}
unsafe extern "C" {
    /// Sets cuda device.
    ///
    /// @param index  Index of the CUDA device to be activated.
    pub fn gpujpeg_set_device(index: ::std::os::raw::c_int);
}
unsafe extern "C" {
    /// Calculate size for image by parameters
    ///
    /// @param param  Image parameters
    /// # return
    /// calculate size
    pub fn gpujpeg_image_calculate_size(param: *mut gpujpeg_image_parameters) -> usize;
}
unsafe extern "C" {
    /// Load image from file
    ///
    /// Allocated image must be freed by gpujpeg_image_load_from_file().
    ///
    /// @param         filaname    Image filename
    /// @param[out]    image       Image data buffer allocated as CUDA host buffer
    /// @param[in,out] image_size  Image data buffer size (can be specified for verification or 0 for retrieval)
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_image_load_from_file(
        filename: *const ::std::os::raw::c_char,
        image: *mut *mut u8,
        image_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Save image to a file
    ///
    /// File format is deduced from the filename extension (if any).
    ///
    /// Use the extension \"XXX\" (eg. \"image.XXX\") to automatically select the
    /// extension according to param_image. PNM is used for grayscale or RGB, PAM for
    /// RGBA, Y4M ottherwise. \"XXX\" placeholder in filename is replaced with used
    /// extension. It is user responsibility to ensure that @ref filename is writable
    /// in this case.
    ///
    /// @param filaname  Image filename
    /// @param image  Image data buffer
    /// @param image_size  Image data buffer size
    /// @param param_image Image properties (may be NULL)
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_image_save_to_file(
        filename: *const ::std::os::raw::c_char,
        image: *const u8,
        image_size: usize,
        param_image: *const gpujpeg_image_parameters,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Reads/obtains properties from uncompressed file (PNM etc.)
    ///
    /// For files without header (.rgb, .yuv...) it obtains only color space pixel format deduced from file extension.
    ///
    /// @retval 0 on success; != 0 on error
    /// @retval -1 on error
    /// @retval 1 only color space and  pixel format was deduced from file extension (see above)
    pub fn gpujpeg_image_get_properties(
        filename: *const ::std::os::raw::c_char,
        param_image: *mut gpujpeg_image_parameters,
        file_exists: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Destroys image allocated by GPUJPEG (eg. gpujpeg_image_load_from_file())
    ///
    /// @param image  Image data buffer
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_image_destroy(image: *mut u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Print range info for image samples
    ///
    /// @param filename
    /// @param width
    /// @param height
    /// @param sampling_factor
    pub fn gpujpeg_image_range_info(
        filename: *const ::std::os::raw::c_char,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        sampling_factor: gpujpeg_pixel_format,
    );
}
unsafe extern "C" {
    /// Convert image
    ///
    /// # note
    /// currently defunct
    ///
    /// @param input
    /// @param filename
    /// @param param_image_from
    /// @param param_image_to
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_image_convert(
        input: *const ::std::os::raw::c_char,
        output: *const ::std::os::raw::c_char,
        param_image_from: gpujpeg_image_parameters,
        param_image_to: gpujpeg_image_parameters,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_opengl_context {
    _unused: [u8; 0],
}
unsafe extern "C" {
    /// Init OpenGL context
    ///
    /// This call is optional - initializes OpenGL context, thus doesn't need to be
    /// called when context already exists. If not called, however, it may be required
    /// to run glewInit() from client code prior to running GPUJPEG with GL interoperability.
    ///
    /// Returned pointer should be freed with gpujpeg_opengl_destroy() when done.
    ///
    /// @param[out] ctx pointer to OpenGL context data (to be passed to gpujpeg_opengl_destroy())
    /// # return
    ///      0  if succeeds, otherwise nonzero
    /// # return
    ///     -1  if initialization fails
    /// # return
    ///     -2  if OpenGL support was not compiled in
    pub fn gpujpeg_opengl_init(ctx: *mut *mut gpujpeg_opengl_context) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Destroys OpenGL context created with gpujpeg_opengl_init()
    ///
    /// # return
    /// NULL if failed, otherwise state pointer
    pub fn gpujpeg_opengl_destroy(arg1: *mut gpujpeg_opengl_context);
}
unsafe extern "C" {
    /// Create OpenGL texture
    ///
    /// @param width
    /// @param height
    /// @param data
    /// # return
    /// nonzero texture id if succeeds, otherwise 0
    pub fn gpujpeg_opengl_texture_create(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Set data to OpenGL texture
    ///
    /// @param texture_id
    /// @param data
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_opengl_texture_set_data(
        texture_id: ::std::os::raw::c_int,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Get data from OpenGL texture
    ///
    /// @param texture_id
    /// @param data
    /// @param data_size
    /// # return
    /// 0 data if succeeds, otherwise nonzero
    pub fn gpujpeg_opengl_texture_get_data(
        texture_id: ::std::os::raw::c_int,
        data: *mut u8,
        data_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Destroy OpenGL texture
    ///
    /// @param texture_id
    pub fn gpujpeg_opengl_texture_destroy(texture_id: ::std::os::raw::c_int);
}
pub const gpujpeg_opengl_texture_type_GPUJPEG_OPENGL_TEXTURE_READ: gpujpeg_opengl_texture_type = 1;
pub const gpujpeg_opengl_texture_type_GPUJPEG_OPENGL_TEXTURE_WRITE: gpujpeg_opengl_texture_type = 2;
/// Registered OpenGL texture type
pub type gpujpeg_opengl_texture_type = ::std::os::raw::c_int;
/// Represents OpenGL texture that is registered to CUDA,
/// thus the device pointer can be acquired.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_opengl_texture {
    /// Texture id
    pub texture_id: ::std::os::raw::c_int,
    /// Texture type
    pub texture_type: gpujpeg_opengl_texture_type,
    /// Texture width
    pub texture_width: ::std::os::raw::c_int,
    /// Texture height
    pub texture_height: ::std::os::raw::c_int,
    /// Texture pixel buffer object type
    pub texture_pbo_type: ::std::os::raw::c_int,
    /// Texture pixel buffer object id
    pub texture_pbo_id: ::std::os::raw::c_int,
    /// Texture PBO resource for CUDA
    pub texture_pbo_resource: *mut cudaGraphicsResource,
    /// Texture callbacks parameter
    pub texture_callback_param: *mut ::std::os::raw::c_void,
    /// Texture callback for attaching OpenGL context (by default not used)
    pub texture_callback_attach_opengl:
        ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
    /// Texture callback for detaching OpenGL context (by default not used)
    pub texture_callback_detach_opengl:
        ::std::option::Option<unsafe extern "C" fn(param: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_opengl_texture"][::std::mem::size_of::<gpujpeg_opengl_texture>() - 56usize];
    ["Alignment of gpujpeg_opengl_texture"]
        [::std::mem::align_of::<gpujpeg_opengl_texture>() - 8usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_id"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_id) - 0usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_type"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_type) - 4usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_width"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_width) - 8usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_height"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_height) - 12usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_pbo_type"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_pbo_type) - 16usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_pbo_id"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_pbo_id) - 20usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_pbo_resource"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_pbo_resource) - 24usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_callback_param"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_callback_param) - 32usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_callback_attach_opengl"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_callback_attach_opengl) - 40usize];
    ["Offset of field: gpujpeg_opengl_texture::texture_callback_detach_opengl"]
        [::std::mem::offset_of!(gpujpeg_opengl_texture, texture_callback_detach_opengl) - 48usize];
};
unsafe extern "C" {
    /// Register OpenGL texture to CUDA
    ///
    /// @param texture_id
    /// # return
    /// allocated registred texture structure
    pub fn gpujpeg_opengl_texture_register(
        texture_id: ::std::os::raw::c_int,
        texture_type: gpujpeg_opengl_texture_type,
    ) -> *mut gpujpeg_opengl_texture;
}
unsafe extern "C" {
    /// Unregister OpenGL texture from CUDA. Deallocated given
    /// structure.
    ///
    /// @param texture
    pub fn gpujpeg_opengl_texture_unregister(texture: *mut gpujpeg_opengl_texture);
}
unsafe extern "C" {
    /// Map registered OpenGL texture to CUDA and return
    /// device pointer to the texture data
    ///
    /// @param texture
    /// @param data_size  Data size in returned buffer
    /// @param copy_from_texture  Specifies whether memory copy from texture
    ///                           should be performed
    pub fn gpujpeg_opengl_texture_map(
        texture: *mut gpujpeg_opengl_texture,
        data_size: *mut usize,
    ) -> *mut u8;
}
unsafe extern "C" {
    /// Unmap registered OpenGL texture from CUDA and the device
    /// pointer is no longer useable.
    ///
    /// @param texture
    /// @param copy_to_texture  Specifies whether memoryc copy to texture
    ///                         should be performed
    pub fn gpujpeg_opengl_texture_unmap(texture: *mut gpujpeg_opengl_texture);
}
unsafe extern "C" {
    /// Get color space name
    ///
    /// @param color_space
    pub fn gpujpeg_color_space_get_name(
        color_space: gpujpeg_color_space,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    /// Returns pixel format by string name
    pub fn gpujpeg_pixel_format_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> gpujpeg_pixel_format;
}
unsafe extern "C" {
    pub fn gpujpeg_print_pixel_formats();
}
unsafe extern "C" {
    /// Returns color space by string name
    pub fn gpujpeg_color_space_by_name(name: *const ::std::os::raw::c_char) -> gpujpeg_color_space;
}
unsafe extern "C" {
    /// Returns number of color components in pixel format
    pub fn gpujpeg_pixel_format_get_comp_count(
        pixel_format: gpujpeg_pixel_format,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Returns name of the pixel format
    pub fn gpujpeg_pixel_format_get_name(
        pixel_format: gpujpeg_pixel_format,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    /// Returns true if a pixel format is planar
    pub fn gpujpeg_pixel_format_is_planar(
        pixel_format: gpujpeg_pixel_format,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gpujpeg_device_reset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_encoder {
    _unused: [u8; 0],
}
/// Encoder will use custom input buffer
pub const gpujpeg_encoder_input_type_GPUJPEG_ENCODER_INPUT_IMAGE: gpujpeg_encoder_input_type = 0;
/// Encoder will use OpenGL Texture PBO Resource as input buffer
pub const gpujpeg_encoder_input_type_GPUJPEG_ENCODER_INPUT_OPENGL_TEXTURE:
    gpujpeg_encoder_input_type = 1;
/// Encoder will use custom GPU input buffer
pub const gpujpeg_encoder_input_type_GPUJPEG_ENCODER_INPUT_GPU_IMAGE: gpujpeg_encoder_input_type =
    2;
/// Encoder input type
pub type gpujpeg_encoder_input_type = ::std::os::raw::c_int;
/// Encoder input structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_encoder_input {
    /// Output type
    pub type_: gpujpeg_encoder_input_type,
    /// Image data
    pub image: *mut u8,
    /// Registered OpenGL Texture
    pub texture: *mut gpujpeg_opengl_texture,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_encoder_input"][::std::mem::size_of::<gpujpeg_encoder_input>() - 24usize];
    ["Alignment of gpujpeg_encoder_input"]
        [::std::mem::align_of::<gpujpeg_encoder_input>() - 8usize];
    ["Offset of field: gpujpeg_encoder_input::type_"]
        [::std::mem::offset_of!(gpujpeg_encoder_input, type_) - 0usize];
    ["Offset of field: gpujpeg_encoder_input::image"]
        [::std::mem::offset_of!(gpujpeg_encoder_input, image) - 8usize];
    ["Offset of field: gpujpeg_encoder_input::texture"]
        [::std::mem::offset_of!(gpujpeg_encoder_input, texture) - 16usize];
};
unsafe extern "C" {
    /// Set encoder input to image data
    ///
    /// @param encoder_input  Encoder input structure
    /// @param image  Input image data
    /// # return
    /// void
    /// @sa gpujpeg_encoder_input_image
    pub fn gpujpeg_encoder_input_set_image(input: *mut gpujpeg_encoder_input, image: *mut u8);
}
unsafe extern "C" {
    /// Set encoder input to GPU image data
    ///
    /// @param encoder_input  Encoder input structure
    /// @param image GPU image data
    /// # return
    /// void
    /// @sa gpujpeg_encoder_input_gpu_image
    pub fn gpujpeg_encoder_input_set_gpu_image(input: *mut gpujpeg_encoder_input, image: *mut u8);
}
unsafe extern "C" {
    /// Set encoder input to OpenGL texture
    ///
    /// @param encoder_input  Encoder input structure
    /// @param texture_id  OpenGL texture id
    /// # return
    /// void
    /// @sa gpujpeg_encoder_input_set_texture
    pub fn gpujpeg_encoder_input_set_texture(
        input: *mut gpujpeg_encoder_input,
        texture: *mut gpujpeg_opengl_texture,
    );
}
unsafe extern "C" {
    /// alternative to @ref gpujpeg_encoder_input_set_image returning the struct as a return value
    pub fn gpujpeg_encoder_input_image(image: *mut u8) -> gpujpeg_encoder_input;
}
unsafe extern "C" {
    /// alternative to @ref gpujpeg_encoder_input_set_gpu_image returning the struct as a return value
    pub fn gpujpeg_encoder_input_gpu_image(image: *mut u8) -> gpujpeg_encoder_input;
}
unsafe extern "C" {
    /// alternative to @ref gpujpeg_encoder_input_set_texture returning the struct as a return value
    pub fn gpujpeg_encoder_input_texture(
        texture: *mut gpujpeg_opengl_texture,
    ) -> gpujpeg_encoder_input;
}
unsafe extern "C" {
    /// Create JPEG encoder
    ///
    /// @param stream CUDA stream to be used, may be cudaStreamDefault (0x00)
    /// # return
    /// encoder structure if succeeds, otherwise NULL
    pub fn gpujpeg_encoder_create(stream: cudaStream_t) -> *mut gpujpeg_encoder;
}
unsafe extern "C" {
    /// Compute maximum number of image pixels (width x height) which can be encoded by given memory size.
    ///
    /// @param encoder
    /// @param param
    /// @param param_image
    /// @param image_input_type
    /// @param memory_size
    /// @param max_pixels
    /// # return
    /// size of used device memory in bytes if succeeds, otherwise 0
    pub fn gpujpeg_encoder_max_pixels(
        param: *mut gpujpeg_parameters,
        param_image: *mut gpujpeg_image_parameters,
        image_input_type: gpujpeg_encoder_input_type,
        memory_size: usize,
        max_pixels: *mut ::std::os::raw::c_int,
    ) -> usize;
}
unsafe extern "C" {
    /// Compute maximum size of device memory which will be used for encoding image with given number of pixels.
    ///
    /// @param encoder
    /// @param param
    /// @param param_image
    /// @param image_input_type
    /// @param max_pixels
    /// # return
    /// size of required device memory in bytes if succeeds, otherwise 0
    pub fn gpujpeg_encoder_max_memory(
        param: *mut gpujpeg_parameters,
        param_image: *mut gpujpeg_image_parameters,
        image_input_type: gpujpeg_encoder_input_type,
        max_pixels: ::std::os::raw::c_int,
    ) -> usize;
}
unsafe extern "C" {
    /// Pre-allocate all encoding buffers for given image pixels.
    ///
    /// @param encoder
    /// @param param
    /// @param param_image
    /// @param image_input_type
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_encoder_allocate(
        encoder: *mut gpujpeg_encoder,
        param: *const gpujpeg_parameters,
        param_image: *const gpujpeg_image_parameters,
        image_input_type: gpujpeg_encoder_input_type,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Compress image by encoder
    ///
    /// @param encoder  Encoder structure
    /// @param param  Parameters for coder
    /// @param param_image  Parameters for image data
    /// @param image  Source image data
    /// @param[out] image_compressed  Pointer to variable where compressed image data buffer will be placed.
    ///                               Returned host buffer is owned by encoder and must not be freed by the caller.
    ///                               Buffer is valid until next gpujpeg_encoder_encode() call.
    /// @param[out] image_compressed_size  Pointer to variable where compressed image size will be placed.
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_encoder_encode(
        encoder: *mut gpujpeg_encoder,
        param: *const gpujpeg_parameters,
        param_image: *const gpujpeg_image_parameters,
        input: *const gpujpeg_encoder_input,
        image_compressed: *mut *mut u8,
        image_compressed_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Returns duration statistics for last encoded image
    /// # return
    /// 0 if succeeds, otherwise nonzero
    /// # note
    /// The values are only informative and for debugging only and thus this is
    /// not considered as a part of a public API.
    /// @deprecated
    /// The encoder now prints the statistics to stdout if gpujpeg_parameters.perf_stats is set.
    /// May be removed in future versions - please report if using this function.
    pub fn gpujpeg_encoder_get_stats(
        encoder: *mut gpujpeg_encoder,
        stats: *mut gpujpeg_duration_stats,
    ) -> ::std::os::raw::c_int;
}
/// for 1 or 3 channel @ref GPUJPEG_YCBCR_JPEG @ref GPUJPEG_HEADER_JFIF, for @ref
/// GPUJPEG_RGB @ref GPUJPEG_HEADER_ADOBE, @ref GPUJPEG_HEADER_SPIFF otherwise
pub const gpujpeg_header_type_GPUJPEG_HEADER_DEFAULT: gpujpeg_header_type = 0;
pub const gpujpeg_header_type_GPUJPEG_HEADER_JFIF: gpujpeg_header_type = 1;
pub const gpujpeg_header_type_GPUJPEG_HEADER_SPIFF: gpujpeg_header_type = 2;
/// Adobe APP8 header
pub const gpujpeg_header_type_GPUJPEG_HEADER_ADOBE: gpujpeg_header_type = 4;
pub type gpujpeg_header_type = ::std::os::raw::c_int;
unsafe extern "C" {
    /// Forces JPEG header to be emitted.
    ///
    /// Header type should be capable of describing the resulting JPEG, eg. JFIF only for BT.601
    /// full-scale YCbCr images. If not, resulting JPEG image may be incompatible with decoders.
    pub fn gpujpeg_encoder_set_jpeg_header(
        encoder: *mut gpujpeg_encoder,
        header_type: gpujpeg_header_type,
    );
}
unsafe extern "C" {
    /// Suggests optimal restart interval to be used for given param_image balancing both image
    /// size and performance.
    /// @param subsampling 444 422 or 420
    pub fn gpujpeg_encoder_suggest_restart_interval(
        param_image: *const gpujpeg_image_parameters,
        subsampling: gpujpeg_sampling_factor_t,
        interleaved: bool,
        verbose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// sets encoder option
    /// @retval GPUJPEG_NOERR  option was sucessfully set
    /// @retval GPUJPEG_ERROR  invalid argument passed
    pub fn gpujpeg_encoder_set_option(
        encoder: *mut gpujpeg_encoder,
        opt: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Destory JPEG encoder
    ///
    /// @param encoder  Encoder structure
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_encoder_destroy(encoder: *mut gpujpeg_encoder) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_decoder {
    _unused: [u8; 0],
}
/// Decoder will use it's internal output buffer
pub const gpujpeg_decoder_output_type_GPUJPEG_DECODER_OUTPUT_INTERNAL_BUFFER:
    gpujpeg_decoder_output_type = 0;
/// Decoder will use custom output buffer
pub const gpujpeg_decoder_output_type_GPUJPEG_DECODER_OUTPUT_CUSTOM_BUFFER:
    gpujpeg_decoder_output_type = 1;
/// Decoder will use OpenGL Texture PBO Resource as output buffer
pub const gpujpeg_decoder_output_type_GPUJPEG_DECODER_OUTPUT_OPENGL_TEXTURE:
    gpujpeg_decoder_output_type = 2;
/// Decoder will use internal CUDA buffer as output buffer
pub const gpujpeg_decoder_output_type_GPUJPEG_DECODER_OUTPUT_CUDA_BUFFER:
    gpujpeg_decoder_output_type = 3;
/// Decoder will use custom CUDA buffer as output buffer
pub const gpujpeg_decoder_output_type_GPUJPEG_DECODER_OUTPUT_CUSTOM_CUDA_BUFFER:
    gpujpeg_decoder_output_type = 4;
/// Decoder output type
pub type gpujpeg_decoder_output_type = ::std::os::raw::c_int;
/// Decoder output structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_decoder_output {
    /// Output type
    pub type_: gpujpeg_decoder_output_type,
    /// Decompressed data
    pub data: *mut u8,
    /// Decompressed data size
    pub data_size: usize,
    /// Decoded image parameters
    pub param_image: gpujpeg_image_parameters,
    /// OpenGL texture
    pub texture: *mut gpujpeg_opengl_texture,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_decoder_output"][::std::mem::size_of::<gpujpeg_decoder_output>() - 56usize];
    ["Alignment of gpujpeg_decoder_output"]
        [::std::mem::align_of::<gpujpeg_decoder_output>() - 8usize];
    ["Offset of field: gpujpeg_decoder_output::type_"]
        [::std::mem::offset_of!(gpujpeg_decoder_output, type_) - 0usize];
    ["Offset of field: gpujpeg_decoder_output::data"]
        [::std::mem::offset_of!(gpujpeg_decoder_output, data) - 8usize];
    ["Offset of field: gpujpeg_decoder_output::data_size"]
        [::std::mem::offset_of!(gpujpeg_decoder_output, data_size) - 16usize];
    ["Offset of field: gpujpeg_decoder_output::param_image"]
        [::std::mem::offset_of!(gpujpeg_decoder_output, param_image) - 24usize];
    ["Offset of field: gpujpeg_decoder_output::texture"]
        [::std::mem::offset_of!(gpujpeg_decoder_output, texture) - 48usize];
};
/// @sa gpujpeg_parametes
/// call gpujpeg_decoder_default_init_parameters() to initialize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpujpeg_decoder_init_parameters {
    /// stream CUDA stream to be used, cudaStreamDefault (0x00) is default
    pub stream: cudaStream_t,
    /// verbosity level (-1 - quiet, 0 - normal, 1 - verbose)
    pub verbose: ::std::os::raw::c_int,
    /// print performance statistics on output
    pub perf_stats: bool,
    /// if FFmpeg specific COM marker \"CS=ITU601\" present, interpret the data as
    /// limited-range BT.709 not BT.601
    pub ff_cs_itu601_is_709: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpujpeg_decoder_init_parameters"]
        [::std::mem::size_of::<gpujpeg_decoder_init_parameters>() - 16usize];
    ["Alignment of gpujpeg_decoder_init_parameters"]
        [::std::mem::align_of::<gpujpeg_decoder_init_parameters>() - 8usize];
    ["Offset of field: gpujpeg_decoder_init_parameters::stream"]
        [::std::mem::offset_of!(gpujpeg_decoder_init_parameters, stream) - 0usize];
    ["Offset of field: gpujpeg_decoder_init_parameters::verbose"]
        [::std::mem::offset_of!(gpujpeg_decoder_init_parameters, verbose) - 8usize];
    ["Offset of field: gpujpeg_decoder_init_parameters::perf_stats"]
        [::std::mem::offset_of!(gpujpeg_decoder_init_parameters, perf_stats) - 12usize];
    ["Offset of field: gpujpeg_decoder_init_parameters::ff_cs_itu601_is_709"]
        [::std::mem::offset_of!(gpujpeg_decoder_init_parameters, ff_cs_itu601_is_709) - 13usize];
};
unsafe extern "C" {
    /// Set default parameters to decoder output structure
    ///
    /// @param output  Decoder output structure
    /// # return
    /// void
    pub fn gpujpeg_decoder_output_set_default(output: *mut gpujpeg_decoder_output);
}
unsafe extern "C" {
    /// Setup decoder output to custom buffer
    ///
    /// @param output        Decoder output structure
    /// @param custom_buffer Custom buffer
    /// # return
    /// void
    pub fn gpujpeg_decoder_output_set_custom(
        output: *mut gpujpeg_decoder_output,
        custom_buffer: *mut u8,
    );
}
unsafe extern "C" {
    /// Set decoder output to OpenGL texture
    ///
    /// @param output  Decoder output structure
    /// # return
    /// void
    pub fn gpujpeg_decoder_output_set_texture(
        output: *mut gpujpeg_decoder_output,
        texture: *mut gpujpeg_opengl_texture,
    );
}
unsafe extern "C" {
    /// Sets output to CUDA buffer
    ///
    /// @param output  Decoder output structure
    pub fn gpujpeg_decoder_output_set_cuda_buffer(output: *mut gpujpeg_decoder_output);
}
unsafe extern "C" {
    /// Setup decoder output to custom CUDA buffer
    ///
    /// @param output          Decoder output structure
    /// @param d_custom_buffer Custom buffer in CUDA device memory
    /// # return
    /// void
    pub fn gpujpeg_decoder_output_set_custom_cuda(
        output: *mut gpujpeg_decoder_output,
        d_custom_buffer: *mut u8,
    );
}
unsafe extern "C" {
    /// Create JPEG decoder
    ///
    /// @sa gpujpeg_decoder_create_with_params
    /// @param stream CUDA stream to be used, may be cudaStreamDefault (0x00)
    /// # return
    /// decoder structure if succeeds, otherwise NULL
    pub fn gpujpeg_decoder_create(stream: cudaStream_t) -> *mut gpujpeg_decoder;
}
unsafe extern "C" {
    pub fn gpujpeg_decoder_default_init_parameters() -> gpujpeg_decoder_init_parameters;
}

unsafe extern "C" {
    /// @brief Create JPEG decoder - extended versison

    /// This version is an alternative to gpujpeg_decoder_create() allowing setting more parameters during initialization
    /// (verbose, perf_stats). Previously, if those needed to be set, it the decoder must have been configured with
    /// gpujpeg_decoder_init().
    ///
    /// @sa gpujpeg_decoder_create
    /// # return
    /// decoder structure if succeeds, otherwise NULL
    pub fn gpujpeg_decoder_create_with_params(
        params: *const gpujpeg_decoder_init_parameters,
    ) -> *mut gpujpeg_decoder;
}
unsafe extern "C" {
    /// Init JPEG decoder for specific image properties
    ///
    /// Following properties are relevant:
    /// - image dimensions, commonent count
    /// - output pixel format that will be requested
    /// - interleaving, restart interval, color_space_internal (usually GPUJPEG_YCBCR_BT601_256LVLS)
    /// - correct subsampling setting
    ///
    /// # note
    /// Doesn't need to be called from user code, buffers will be initialized automatically according to
    /// image properties during decompression.
    ///
    /// @param decoder  Decoder structure
    /// @param[in] param        Parameters for coder, pointed structure is copied
    /// @param[in] param_image  Parameters for image data, pointed structure is copied
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_decoder_init(
        decoder: *mut gpujpeg_decoder,
        param: *const gpujpeg_parameters,
        param_image: *const gpujpeg_image_parameters,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Decompress image by decoder
    ///
    /// @param decoder  Decoder structure
    /// @param image  Source image data
    /// @param image_size  Source image data size
    /// @param image_decompressed  Pointer to variable where decompressed image data buffer will be placed
    /// @param image_decompressed_size  Pointer to variable where decompressed image size will be placed
    /// # return
    /// @ref Errors
    pub fn gpujpeg_decoder_decode(
        decoder: *mut gpujpeg_decoder,
        image: *mut u8,
        image_size: usize,
        output: *mut gpujpeg_decoder_output,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Returns duration statistics for last decoded image
    /// # return
    /// 0 if succeeds, otherwise nonzero
    /// # note
    /// The values are only informative and for debugging only and thus this is
    /// not considered as a part of a public API.
    /// @deprecated
    /// The decoder now prints the statistics to stdout if gpujpeg_parameters.perf_stats is set.
    /// May be removed in future versions - please report if using this function.
    pub fn gpujpeg_decoder_get_stats(
        decoder: *mut gpujpeg_decoder,
        stats: *mut gpujpeg_duration_stats,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Destory JPEG decoder
    ///
    /// @param decoder  Decoder structure
    /// # return
    /// 0 if succeeds, otherwise nonzero
    pub fn gpujpeg_decoder_destroy(decoder: *mut gpujpeg_decoder) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// Sets output format
    ///
    /// If not called, @ref GPUJPEG_CS_DEFAULT and @ref GPUJPEG_PIXFMT_AUTODETECT
    /// are used.
    ///
    /// @param decoder         Decoder structure
    /// @param color_space     Requested output color space,
    ///                        use @ref GPUJPEG_NONE to keep JPEG internal color space;
    ///                        special value @ref GPUJPEG_CS_DEFAULT to decode RGB
    ///                        (or luma for grayscale)
    /// @param sampling_factor Requestd color sampling factor; special values
    ///                        @ref decoder_pixfmt_placeholders can be used
    pub fn gpujpeg_decoder_set_output_format(
        decoder: *mut gpujpeg_decoder,
        color_space: gpujpeg_color_space,
        pixel_format: gpujpeg_pixel_format,
    );
}
unsafe extern "C" {
    /// @copydoc gpujpeg_reader_get_image_info
    pub fn gpujpeg_decoder_get_image_info(
        image: *mut u8,
        image_size: usize,
        param_image: *mut gpujpeg_image_parameters,
        param: *mut gpujpeg_parameters,
        segment_count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    /// sets decoder option
    /// @retval GPUJPEG_NOERR  option was sucessfully set
    /// @retval GPUJPEG_ERROR  invalid argument passed
    pub fn gpujpeg_decoder_set_option(
        decoder: *mut gpujpeg_decoder,
        opt: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
/// Texture PBO resource for CUDA
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphicsResource {
    pub _address: u8,
}
